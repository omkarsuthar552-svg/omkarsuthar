<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <title>Omkar's Magic Shapes</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        #info { position: absolute; top: 20px; left: 20px; color: #00ffcc; z-index: 10; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px; border: 1px solid #00ffcc; line-height: 1.6; }
        video { position: absolute; bottom: 20px; right: 20px; width: 180px; border: 2px solid #00ffcc; border-radius: 10px; transform: scaleX(-1); }
        .highlight { color: #fff; font-weight: bold; text-shadow: 0 0 10px #00ffcc; }
    </style>
</head>
<body>
    <div id="info">
        <div class="highlight" style="font-size: 1.5em; margin-bottom: 5px;">OMKAR'S MAGIC WORLD</div>
        STATUS: <span id="status">कैमरा अनुमति दें...</span><br>
        SHAPE: <span id="current-shape" class="highlight">Sphere</span><br>
        CONTROLS: 1 से 10 उंगलियां दिखाएं
    </div>
    <video id="video-input"></video>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const statusEl = document.getElementById('status');
        const shapeEl = document.getElementById('current-shape');
        const videoElement = document.getElementById('video-input');
        let currentMesh;
        let lastCount = -1;

        // 1. Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        camera.position.z = 35;

        // 2. Shape Creation Logic
        function createShape(type) {
            if (currentMesh) scene.remove(currentMesh);
            let geometry;
            const material = new THREE.MeshNormalMaterial({ wireframe: true });

            switch(type) {
                case 1: geometry = new THREE.SphereGeometry(10, 32, 32); shapeEl.innerText = "1. Sphere"; break;
                case 2: geometry = new THREE.BoxGeometry(15, 15, 15); shapeEl.innerText = "2. Cube"; break;
                case 3: geometry = new THREE.TorusGeometry(10, 3, 16, 100); shapeEl.innerText = "3. Donut"; break;
                case 4: geometry = new THREE.OctahedronGeometry(12); shapeEl.innerText = "4. Diamond"; break;
                case 5: geometry = new THREE.ConeGeometry(10, 20, 32); shapeEl.innerText = "5. Cone"; break;
                case 6: geometry = new THREE.IcosahedronGeometry(12); shapeEl.innerText = "6. Crystal"; break;
                case 7: geometry = new THREE.TorusKnotGeometry(8, 3, 100, 16); shapeEl.innerText = "7. Knot"; break;
                case 8: geometry = new THREE.CylinderGeometry(8, 8, 20, 32); shapeEl.innerText = "8. Cylinder"; break;
                case 9: geometry = new THREE.DodecahedronGeometry(12); shapeEl.innerText = "9. Multi-Face"; break;
                case 10: geometry = new THREE.TetrahedronGeometry(15); shapeEl.innerText = "10. Pyramid"; break;
                default: geometry = new THREE.SphereGeometry(10, 32, 32);
            }
            currentMesh = new THREE.Mesh(geometry, material);
            scene.add(currentMesh);
        }

        createShape(1);

        // 3. Hand Tracking
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });

        hands.onResults((results) => {
            statusEl.innerText = "सिस्टम चालू है ✅";
            if (results.multiHandLandmarks && results.multiHandLandmarks[0]) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Follow Hand
                currentMesh.position.x = (landmarks[9].x - 0.5) * -50;
                currentMesh.position.y = (landmarks[9].y - 0.5) * -30;

                // Counting Fingers
                let count = 0;
                if(landmarks[4].x < landmarks[3].x) count++; // Thumb
                if(landmarks[8].y < landmarks[6].y) count++;
                if(landmarks[12].y < landmarks[10].y) count++;
                if(landmarks[16].y < landmarks[14].y) count++;
                if(landmarks[20].y < landmarks[18].y) count++;

                if(count > 0 && count !== lastCount) {
                    createShape(count);
                    lastCount = count;
                }
            }
        });

        const cam = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cam.start();

        function animate() {
            requestAnimationFrame(animate);
            if (currentMesh) {
                currentMesh.rotation.x += 0.01;
                currentMesh.rotation.y += 0.01;
            }
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
