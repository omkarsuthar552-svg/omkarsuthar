<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <title>Omkar's 10 Shapes Magic</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        #info { position: absolute; top: 20px; left: 20px; color: #00ffcc; z-index: 10; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px; border: 1px solid #00ffcc; }
        video { position: absolute; bottom: 20px; right: 20px; width: 180px; border: 2px solid #00ffcc; border-radius: 10px; transform: scaleX(-1); }
        .highlight { color: #fff; font-weight: bold; text-shadow: 0 0 10px #00ffcc; font-size: 1.2em; }
    </style>
</head>
<body>
    <div id="info">
        <div style="font-size: 1.5em; color: #fff;">OMKAR'S MAGIC WORLD</div>
        उंगलियां दिखाएं (1-10): <span id="finger-count" class="highlight">0</span><br>
        आकार (Shape): <span id="current-shape" class="highlight">Sphere</span>
    </div>
    <video id="video-input"></video>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const shapeEl = document.getElementById('current-shape');
        const countEl = document.getElementById('finger-count');
        const videoElement = document.getElementById('video-input');
        let currentMesh, lastCount = -1;

        // 1. Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        camera.position.z = 35;

        // 2. 10 Shapes Logic
        function createShape(type) {
            if (currentMesh) scene.remove(currentMesh);
            let geometry;
            const material = new THREE.MeshNormalMaterial({ wireframe: true });

            const shapes = {
                1: [new THREE.SphereGeometry(10, 32, 32), "Sphere"],
                2: [new THREE.BoxGeometry(15, 15, 15), "Cube"],
                3: [new THREE.TorusGeometry(10, 3, 16, 100), "Donut"],
                4: [new THREE.OctahedronGeometry(12), "Diamond"],
                5: [new THREE.ConeGeometry(10, 20, 32), "Cone"],
                6: [new THREE.IcosahedronGeometry(12), "Crystal"],
                7: [new THREE.TorusKnotGeometry(8, 3, 100, 16), "Knot"],
                8: [new THREE.CylinderGeometry(8, 8, 20, 32), "Cylinder"],
                9: [new THREE.DodecahedronGeometry(12), "Multi-Face"],
                10: [new THREE.TetrahedronGeometry(15), "Pyramid"]
            };

            const selected = shapes[type] || shapes[1];
            geometry = selected[0];
            shapeEl.innerText = selected[1];
            
            currentMesh = new THREE.Mesh(geometry, material);
            scene.add(currentMesh);
        }
        createShape(1);

        // 3. Dual Hand Tracking (6-10 Fingers)
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ 
            maxNumHands: 2, // अब यह 2 हाथ पहचानेगा
            modelComplexity: 1, 
            minDetectionConfidence: 0.6, 
            minTrackingConfidence: 0.6 
        });

        hands.onResults((results) => {
            let totalFingers = 0;

            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    // Thumb logic
                    const isLeftHand = landmarks[4].x > landmarks[20].x;
                    if (isLeftHand) {
                        if (landmarks[4].x > landmarks[3].x) totalFingers++;
                    } else {
                        if (landmarks[4].x < landmarks[3].x) totalFingers++;
                    }
                    // 4 Fingers logic
                    if (landmarks[8].y < landmarks[6].y) totalFingers++;
                    if (landmarks[12].y < landmarks[10].y) totalFingers++;
                    if (landmarks[16].y < landmarks[14].y) totalFingers++;
                    if (landmarks[20].y < landmarks[18].y) totalFingers++;
                }

                if (totalFingers > 0 && totalFingers !== lastCount) {
                    countEl.innerText = totalFingers;
                    createShape(totalFingers);
                    lastCount = totalFingers;
                }
                
                // Position follow the first hand
                if(results.multiHandLandmarks[0]) {
                    currentMesh.position.x = (results.multiHandLandmarks[0][9].x - 0.5) * -50;
                    currentMesh.position.y = (results.multiHandLandmarks[0][9].y - 0.5) * -30;
                }
            }
        });

        const cam = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cam.start();

        function animate() {
            requestAnimationFrame(animate);
            if (currentMesh) {
                currentMesh.rotation.x += 0.01;
                currentMesh.rotation.y += 0.01;
            }
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
